# Python Object-Oriented Programming (OOP): From Basic to Advanced

This guide covers Python's OOP features with **examples, analogies, and detailed comments**. Each section builds upon the previous one, progressing from **basic to advanced** concepts.

---

## **1️⃣ Basic Class Definition and Objects**

### **🔹 What is a Class?**
A **class** is a blueprint for creating objects. It defines **attributes** (data) and **methods** (functions that act on the data).

📌 **Analogy:** Think of a **class as a blueprint for a house**. The blueprint defines what the house will have (**attributes**) and what can be done in it (**methods**). An **object** is an actual house built from that blueprint.

### **🔹 Creating a Simple Class**
```python
class Dog:
    """A simple class representing a dog."""
    
    # Class attribute (shared by all instances)
    species = "Canis familiaris"
    
    def __init__(self, name, age):
        """Initialize a new Dog object."""
        self.name = name  # Instance attribute (unique to each instance)
        self.age = age
    
    def bark(self):
        """The dog makes a sound."""
        return f"{self.name} says Woof!"
    
    def get_info(self):
        """Return a string with the dog's information."""
        return f"{self.name} is {self.age} years old."

# Creating objects (instances) of the Dog class
fido = Dog("Fido", 3)
bella = Dog("Bella", 5)

# Accessing attributes
print(fido.name)        # Output: Fido
print(bella.age)        # Output: 5
print(fido.species)     # Output: Canis familiaris

# Calling methods
print(fido.bark())      # Output: Fido says Woof!
print(bella.get_info()) # Output: Bella is 5 years old.
```

### **🔹 Key Takeaways**
✅ **Class Attribute**: Shared across all instances (`species = "Canis familiaris"`)
✅ **Instance Attributes**: Unique for each object (`self.name`, `self.age`)
✅ **Methods**: Functions that act on object data (`bark()`, `get_info()`)

---

## **2️⃣ Inheritance**
### **🔹 What is Inheritance?**
**Inheritance** allows a new class to take the attributes and methods of an existing class, reducing code duplication.

📌 **Analogy:** **A child inherits traits from parents** but may also have unique characteristics.

### **🔹 Implementing Inheritance**
```python
class Pet:
    """A base class for all pets."""
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def speak(self):
        return "Some generic pet sound"
    
    def __str__(self):
        return f"{self.name}, age {self.age}"

class Cat(Pet):  # Cat inherits from Pet
    """A class representing a cat, inheriting from Pet."""
    species = "Felis catus"
    
    def __init__(self, name, age, color):
        super().__init__(name, age)  # Call parent constructor
        self.color = color  # Additional attribute
    
    def speak(self):
        return f"{self.name} says Meow!"
    
    def purr(self):
        return f"{self.name} purrs contentedly."

# Creating an instance
whiskers = Cat("Whiskers", 4, "gray")

# Checking inheritance
print(isinstance(whiskers, Cat))   # Output: True
print(isinstance(whiskers, Pet))   # Output: True

# Accessing attributes and methods
print(whiskers.name)        # From Pet
print(whiskers.color)       # From Cat
print(whiskers.speak())     # Overridden method, Output: Whiskers says Meow!
print(whiskers.purr())      # Output: Whiskers purrs contentedly.
```

### **🔹 Key Takeaways**
✅ **`super().__init__()`**: Calls the parent class’s constructor
✅ **Inherited Attributes & Methods**: `name`, `age` are from `Pet`
✅ **Overriding Methods**: `speak()` in `Cat` replaces `speak()` in `Pet`
✅ **New Methods**: `purr()` is unique to `Cat`

---

## **3️⃣ Encapsulation**
### **🔹 What is Encapsulation?**
Encapsulation **restricts access** to certain attributes and methods to prevent unintended modifications.

📌 **Analogy:** A car engine is **hidden under a hood**. Users interact with the car using the **steering wheel and pedals** (public methods), without direct access to the engine (private data).

### **🔹 Implementing Encapsulation**
```python
class BankAccount:
    """A class representing a bank account with private attributes."""
    
    def __init__(self, owner, initial_balance=0):
        self.owner = owner
        self.__balance = initial_balance  # Private attribute
        self._transaction_count = 0       # Protected attribute
    
    def deposit(self, amount):
        if amount <= 0:
            raise ValueError("Deposit amount must be positive")
        self.__balance += amount
        self._transaction_count += 1
        return self.__balance
    
    def withdraw(self, amount):
        if amount <= 0 or amount > self.__balance:
            raise ValueError("Invalid withdrawal amount")
        self.__balance -= amount
        self._transaction_count += 1
        return self.__balance
    
    def get_balance(self):
        return self.__balance

# Creating an account
account = BankAccount("John Doe", 1000)

# Using methods to access balance
print(account.deposit(500))   # Output: 1500
print(account.withdraw(200))  # Output: 1300
print(account.get_balance())  # Output: 1300

# Trying to access private attribute directly (will cause an error)
# print(account.__balance)  # AttributeError

# Accessing private attributes using Python name mangling (not recommended)
print(account._BankAccount__balance)  # Output: 1300
```

### **🔹 Key Takeaways**
✅ **Private Attributes (`__balance`)**: Cannot be accessed directly
✅ **Protected Attributes (`_transaction_count`)**: Can be accessed but shouldn't be modified outside the class
✅ **Encapsulation provides controlled access** to sensitive data

---

## **🚀 Final Thoughts**
- **Classes** organize data and behavior in Python.
- **Inheritance** reduces code duplication.
- **Encapsulation** prevents unintended modifications to data.

Mastering OOP makes Python programming **cleaner, reusable, and efficient!** 🚀
